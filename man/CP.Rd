% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RCP.R
\name{CP}
\alias{CP}
\title{Change Point Detection}
\description{
Hierarchical change-point detection method for multivariate time series using Euclidean distance or user-defined distance.
}

\usage{
CP(ts, method = "powell", mss = 3, pt = 0.05,
  is_Euclidean_distance = TRUE, distance = NULL, block_size = 1)
}
\arguments{
\item{ts}{Input time series, of dimension n * p, each row is an observation.}
\item{method}{Which method is employed, should be one of 'origin', 'gss' or 'powell'.}
\item{mss}{Minimal segment size, the smallest tolerant distance between any two detected change points.}
\item{pt}{Threshold of the estimated probability, default is 0.05}
\item{is_Euclidean_distance}{Whether Euclidean distance is employed. \code{distance} is necessary if \code{is_Euclidean_distance = FALSE}.}
\item{distance}{Sample distance matrix, defined by user and necessary if \code{is_Euclidean_distance = FALSE}.}
\item{block_size}{Block size empolyed for moving block bootstrap method, default is 1 }

}

\value{
\code{CP} returns a vector containing all detected locations of change points.
}

\author{
Qiang Zhang}


\examples{
#---- Multivariate time series using Euclidean distance ----


set.seed(666)
ts = matrix(rnorm(n = 180, mean = 0, sd = 1), ncol =3)

ts[31:60, 2] = ts[31:60, 2] + 2
print(CP(ts))

#---- Manifold data using circular distance ----
# Suppose ts is a univariate time series with 120 observations.
# The first 40 and the last 40 observations obey uniform distribution P1
# The middle 40 observations obey uniform distribution P2
# P1 ~ Unif([-pi/6, pi/6)U[11pi/6, 13pi/6))
# P2 ~  Unif([pi/3, 2pi/3)U[[7pi/3, 8pi/3))
# Circular distance is employed as below:
# d(X_i ,X_j ) = min(|X_i - X_j |, |2pi - |X_i - X_j ||).

set.seed(999)
ts = runif(n = 120, min = -pi/6, max = pi/6)
flag = rbinom(120, size = 1, prob = 0.5)
ts[1:40] = ts[1:40] + flag[1:40]*2*pi
ts[41:80] = ts[41:80] + flag[41:80]*2*pi + pi
ts[81:120] = ts[81:120] + flag[81:120]*2*pi

dist = as.matrix(dist(ts, method = 'manhattan', upper = TRUE, diag = TRUE))
tmp = abs(2 * pi - abs(dist))
dist[which(dist > tmp)] = tmp[which(dist > tmp)]

print(CP(ts = ts, 'powell', is_Euclidean_distance = FALSE, distance = dist))

}













